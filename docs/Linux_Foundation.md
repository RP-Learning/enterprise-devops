# Linux Foundations â€“ What We Learned, Why It Matters, and How We Fixed Issues

This document consolidates Linux fundamentals learned during environment setup and core system exploration. It focuses on understanding system behavior, production relevance, and real-world problem handling.

---

## Linux Filesystem Structure

### Purpose of Key Directories

- **/etc**  
  Contains system-wide and application configuration files. Services read their behavior from /etc during startup and runtime. Incorrect configuration or permissions here can prevent applications from starting or cause outages.

- **/var/log**  
  Stores system and application logs. This is the first place to look during incidents because logs capture runtime behavior, errors, and failure timelines.

- **/home**  
  Contains user-specific data and workspaces. This is where non-system users operate and where development, scripts, and tools are commonly stored.

- **/bin and /usr/bin**  
  Store essential binaries and executable programs. These directories are part of the system PATH, allowing commands to be executed directly from the shell.

- **/proc**  
  A virtual filesystem that exposes real-time kernel and process information. Files here are generated dynamically by the kernel and do not exist on disk.

---

### Difference Between Configuration, Logs, Binaries, and Runtime Data

- **Configuration**  
  Defines how a system or application should behave. Typically stored in /etc. Changes here affect startup and runtime behavior.

- **Logs**  
  Record what actually happened during execution. Stored in /var/log and used for troubleshooting, monitoring, and root cause analysis.

- **Binaries**  
  Executable programs that perform actions. Stored in /bin or /usr/bin. Without execute permission, binaries cannot run.

- **Runtime Data**  
  Dynamic data generated while the system is running, such as process state and kernel metrics. Often accessed via /proc or stored under /var.

---

### Virtual Filesystems vs Disk-Backed Filesystems

- **Disk-backed filesystems**  
  Store persistent data on disk (e.g., /etc, /home, /var). Data survives reboots.

- **Virtual filesystems**  
  Represent live system state and are generated by the kernel (e.g., /proc, /sys). Data resets on reboot and reflects real-time information.

Understanding this distinction prevents confusion during debugging and disk inspection.

---

## Paths and Context Awareness

- Relative paths depend on the current working directory
- Absolute paths always start from /
- Production scripts should prefer absolute paths to avoid ambiguity
- Running `pwd` before critical commands prevents mistakes

---

## Permissions and Ownership

- Linux permissions are based on user, group, and others
- Read, write, and execute permissions determine what actions are allowed
- Applications fail if they cannot read configs, write logs, or execute binaries
- Permissions are a correctness mechanism, not just a security feature

---

## Processes and Runtime Behavior

- A process is a running instance of a program
- Each process has a PID, owner, and resource usage
- Snapshot views show state at a moment in time
- Real-time views show changing behavior during incidents

---

## CPU and Load

- CPU cores define parallel execution capacity
- Load average represents processes waiting for CPU or I/O
- High load indicates contention, not necessarily high CPU usage

---

## Memory Management

- Linux aggressively uses memory for caching
- Low free memory is normal
- Available memory is the correct metric for diagnosing pressure

---

## Signals and Process Termination

- Signals are used to control process behavior
- SIGTERM allows graceful shutdown
- SIGKILL forcefully terminates without cleanup
- Graceful shutdown prevents corruption and instability

---

## Challenges Faced and How They Were Fixed

### Permission Denied Errors
**Cause:** Restricted system directories  
**Fix:** Suppressed errors or elevated privileges only when required  
**Lesson:** Permission denied is expected behavior, not failure

---

### Relative vs Absolute Path Issues
**Cause:** Running commands from an unexpected working directory  
**Fix:** Used absolute paths and verified context with pwd  
**Lesson:** Context awareness prevents production mistakes

---

### High CPU / Memory Symptoms
**Cause:** Resource contention from running processes  
**Fix:** Identified offenders using ps/top and applied graceful termination  
**Lesson:** Diagnose before acting

---

## Key Mental Models Gained

- Linux is strict by design, not hostile
- The filesystem explains system behavior
- Most failures come from misunderstanding fundamentals
- Observation always precedes optimization

---


